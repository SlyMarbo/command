package command

import (
	"bufio"
	"io"
	"errors"
	//"strconv"
	"strings"
)

// Scanner provides a convenient interface for reading data such as
// a file of newline-delimited lines of text. Successive calls to
// the Scan method will step through the 'tokens' of a file, skipping
// the bytes between the tokens. The specification of a token is
// defined by a split function of type SplitFunc; the default split
// function breaks the input into lines with line termination stripped. Split
// functions are defined in this package for scanning a file into
// lines, bytes, UTF-8-encoded runes, and space-delimited words. The
// client may instead provide a custom split function.
//
// Scanning stops unrecoverably at EOF, the first I/O error, or a token too
// large to fit in the buffer. When a scan stops, the reader may have
// advanced arbitrarily far past the last token. Programs that need more
// control over error handling or large tokens, or must run sequential scans
// on a reader, should use bufio.Reader instead.
//
// If CaseInsensitive is set, all token methods will return and use
// case insensitive functionality, with input converted to lower case.
type Scanner struct {
	s *bufio.Scanner
	t *Token
	CaseInsensitive bool
}

// NewScanner returns a new Scanner to read from r.
// The split function defaults to ScanLines.
func NewScanner(r io.Reader, caseInsensitive bool) *Scanner {
	out := new(Scanner)
	out.s = bufio.NewScanner(r)
	out.CaseInsensitive = caseInsensitive
	return out
}

// Err returns the first non-EOF error that was encountered by the Scanner.
func (s *Scanner) Err() error {
	if s.s != nil {
		return s.s.Err()
	} else {
		return errors.New("Error: Scanner not initialised.")
	}
}

// Scan advances the Scanner to the next token, which will then be
// available through the Bytes or Text method. It returns false when the
// scan stops, either by reaching the end of the input or an error.
// After Scan returns false, the Err method will return any error that
// occurred during scanning, except that if it was io.EOF, Err
// will return nil.
func (s *Scanner) Scan() bool {
	if s.s != nil {
		b := s.s.Scan()
		if b {
			str := s.s.Text()
			if s.CaseInsensitive {
				str = strings.ToLower(str)
			}
			s.t = &Token{str, str, s.CaseInsensitive}
		}
		return b
	}
	return false
}

// Split sets the split function for the Scanner. If called, it must be
// called before Scan. The default split function is ScanLines.
func (s *Scanner) Split(split bufio.SplitFunc) {
	if s.s != nil {
		s.s.Split(split)
	}
}

// Token returns the most recent token generated by a call to Scan.
func (s *Scanner) Token() *Token {
	return s.t
}

// Token represents a token scanned from a Scanner's input.
type Token struct {
	s string
	b string
	c bool
}

// Blank returns true when the token is the empty string.
func (t *Token) Blank() bool {
	return t.s == ""
}

// Body returns the token, possibly after modification by
// HasPrefix and HasSuffix.
func (t *Token) Body() string {
	return t.b
}

// Bytes returns the raw bytes of the token generated by a call
// to Scan.
func (t *Token) Bytes() []byte {
	return []byte(t.s)
}

// Equals returns true if the token is the same as any of the
// provided strings.
func (t *Token) Equals(tokens ...string) bool {
	for _, token := range tokens {
		if token == t.s {
			return true
		}
	}
	return false
}

// HasPrefix returns true if the token has the given prefix. If
// the prefix matches, the string will be accessible with Body,
// with the prefix removed. The full string (with prefix) is
// still accessible with String.
func (t *Token) HasPrefix(prefix string) bool {
	if t.c {
		prefix = strings.ToLower(prefix)
	}
	if strings.HasPrefix(t.b, prefix) {
		t.b = t.b[len(prefix):]
		return true
	}
	return false
}

// HasSuffix returns true if the token has the given suffix. If
// the suffix matches, the string will be accessible with Body,
// with the suffix removed. The full string (with suffix) is
// still accessible with String.
func (t *Token) HasSuffix(suffix string) bool {
	if t.c {
		suffix = strings.ToLower(suffix)
	}
	if strings.HasSuffix(t.b, suffix) {
		t.b = t.b[:len(t.b)-len(suffix)]
		return true
	}
	return false
}

// String returns the token generated by a call to Scan
// as a newly allocated string holding its bytes.
func (t *Token) String() string {
	return t.s
}
